#include <iostream> //Файл заголовков, подключение ввода/вывода
#include "func.h"
//#include <iomanip>

using namespace std; //не писать префиксы (стандартное пространство имён)

namespace MySpace { //пространства имён
    int myVAr;
}

//Перменные
/*
глобальные
статические
локальные
*/

int GLOBAL;//по умолчанию = 0
//extern GLOB; //заимствование глобальных переменных с других классов
static int STATIC; //переменная внутри одного класса (если создать её в функции
// то она будет существовать во всём коде, но работать в одной функции)

//Глобальная переменная на весь код появляется в начале кода и умирает в конце, используется везде

void localInt() {
    bool lessen1 = false;
    //переменная видна в данном блоке кода
    //по умолчанию = NULL
}

void printer(); //объявление сигнатур
int inter(int a);

int main()
{
    //system("chcp 1251"); //изменение кодировки вывода
    //setlocale(LC_ALL, "Russian"); - аналог для вывода русских букв
    //Типы данных и работа с ними в C++
    bool lessen1 = false;
    string strLessen1 = (lessen1) ? "Лекция 1:\n \n" : "Лекция 1 скрыта\n";
    cout << strLessen1;
    if (lessen1) {
        /*
        Переменная — именованная область памяти с определённым типом.
        Тип определяет:
        - размер памяти;
        - формат хранения;
        - допустимые операции.
        */

        //целые знаковые
        char c; //Если инециализировать переменную, но не предать ей значения - код не скомпилируется 
        short s = 1;
        int i = 2;
        long l = 3;
        long long ll = 4;
        //целые беззнаковые
        unsigned int ui = 5;
        //вещественные
        float f = 1.1;
        double d = 2.2;
        //символьные
        //char может хранить как число, так и символ
        c = 1;
        wchar_t w_t = 'b';
        //логические
        bool b = true; // или = 1
        b = false; // или = 0
        //беззнаковые - подстраиваются сами, по умолчанию int
        unsigned a = 1;

        /*
        Пространства имён (namespace)
        Позволяют избегать конфликтов имён.
        Объявление: см закладку
        Использование:
        */
        MySpace::myVAr = 3;

        /*
        Арифметические операции
        Стандартные + - * / %
        Инкремент и декремент:
        */
        int I = 1;
        cout << "Изменение переменной действиями I++, ++I, I *= 2, I -= 2: " << endl;
        I++; //возвращает старое значение, потом увеличивает.
        cout << I << endl;
        ++I; //увеличивает и возвращает новое значение
        cout << I << endl;
        I *= 2;
        cout << I << endl;
        I -= 2;
        cout << I << endl << "\n";

        cout << "разнца между префиксом и постфиксом значения first и second до выполнения кода = 1" << endl;
        int first = 1;
        int toFirst = ++first;
        cout << "first = " << first << "; toFirst = " << toFirst << "; int toFirst = ++first;" << endl;

        int second = 1;
        int toSecond = second++;
        cout << "second = " << second << "; toSecond = " << toSecond << "; int toSecond = second++;" << endl << "\n";

        /*
        Целочисленное деление
        Целое ÷ целое → округляется вниз.
        Чтобы получить дробный результат, приведи хотя бы один операнд к double.
        */

        cout << "Изменение переменной при целочисленном делении" << endl;
        int num = 10;
        double res = num / 6; //не явное преобразование
        cout << res << endl;
        res = num / 6.0; //не явное преобразование
        res = num / (double)6; //явное преобразование
        cout << res << endl << "\n";

        /*
        cout << - вывод
        cin >> - ввод
        cerr << - вывод ошибки
        для нескольких переменных дублируем << или >>
        endl или \n - перевод на новую строку
        */

        cerr << "cerr выводит ошибки без буферизации" << endl << "\n";

        /*
        тернарная операция если A>B, X=A, иначе X=B
        */

        int A = 1;
        int B = 2;
        int X = (A > B) ? A : B;

        //Условные операторы

        /*
        операторы < > <= >= == !=
        && (и) - останавливается при первом 0, || (или) - останавливается при первой 1, ! (не)
        задание лог. переменной:
        */

        bool bol = 4 == 5;
        cout << "задание лог. переменной bool bol = 4 == 5: " << bol << endl << "\n";

        /*
        условные операторы:
        if (условие) оператор; else оператор; - простая форма

        составной оператор:
        if (условие) {
            Блок кода
        }
        else if (условие если первое условие не выполняется){
            Блок кода
        }
        else {
            Блок кода
        }
        */

        if (1 < 2) bol = true; else bol = false;

        // оператор switch
        const bool ON_CIN_SWITCH = false;
        char switchChar;
        cout << "оператора switch" << endl;
        if (ON_CIN_SWITCH) {
            cout << "оператора switch. Введите число от 1 до 3 или a: ";
            cin >> switchChar;
        }
        else switchChar = 3;

        switch (switchChar)
        { //в case всегда константы, только целочисленные данные
        case '1':
            cout << "если switchInt = 1" << endl;
            switchChar = '2'; //без break, switch продолжит проваливаться в case-ы, вплоть до defaulte;
        case '2':
        case 'a':
            cout << "если switchInt = a или 2" << endl;
            switchChar = '3';
            break;
        case '3':
            cout << "если switchInt = 3" << endl;
        default:
            cout << "стандартный вывод (если не 1 и не 2)" << endl;
            break;
        }
        cout << endl;

        // тернарные операции см. закладку
    }
    //Циклические операторы
    bool lessen2 = false;
    string strLessen2 = (lessen2) ? "Лекция 2:\n \n" : "Лекция 2 скрыта\n";
    cout << strLessen2;
    if (lessen2) {
        /*
        Цикл — это повторяющееся выполнение набора операторов.
        Алгоритмы с повторами называются циклическими.
        */

        //Цикл с предусловием while
        /*
        Условие проверяется до выполнения тела цикла.
        Если условие сразу ложно, тело не выполнится ни разу.

        Логика:
        Перед каждой итерацией → проверка условия.
        Если условие = true → выполняется тело цикла.
        Если false → цикл завершается.

        Когда использовать:
        Количество повторов заранее неизвестно.
        Нужно проверять условие до выполнения тела.
        */

        while (true)
        {
            cout << "цикл while: \n";;
            break;
        }

        
        //Цикл с постусловием do-while
        /*
        Тело цикла выполняется минимум 1 раз, потому что проверка условия выполняется после тела.

        Когда использовать:
        Когда нужно выполнить тело цикла минимум один раз, например:
        повторный ввод данных до корректного значения
        меню программы
        
        Синтаксис:
        */
        do {
            cout << "цикл do-while\n \n";
            break;
        } while (true);

        //Циклы с параметром (for)
        /*
        Цикл for лучше подходит, когда заранее известно количество итераций.
        Синтаксис:
        for (инициализация; условие; изменение)
            оператор;

        Параметры цикла:
        инициализация — выполняется 1 раз перед первым проходом
        условие — проверяется перед каждой итерацией
        изменение — выполняется после каждого прохода
        */

        for (int i = 0; i <= 10; i++) { // можно использовать готовые переменные
            cout << "цикл for\n \n";
            break;
        }

        //Безусловный цикл for (аналог while(true))
        for (;;) {
            cout << "бузословный цикл for\n \n";
            break;
        }
    }

    //Обработка одномерных массивов
    bool lessen3 = false;
    string strLessen3 = (lessen3) ? "Лекция 3:\n \n" : "Лекция 3 скрыта\n";
    cout << strLessen3;
    if (lessen3) {
        /*
        Массив — это набор однотипных данных, расположенных в памяти подряд и объединённых общим именем.
        когда нужно много переменных одного типа;
        для удобства перебора данных циклом;
        для компактного хранения данных.

        имеют одинаковый тип;
        хранятся непрерывно в памяти — это ускоряет доступ;
        доступны по индексу, начинающемуся с 0.
        Пример:
        */
        cout << "Обработка одномерных массивов\n\n";
        int mas[5] = {0,1,2,3,4}; //имеет элементы от mas[0] до mas[4]

        // В С++ нельзя объявлять массив переменного размера (кроме VLA в некоторых компиляторах как расширение)
        const int LEN = 10;
        double masDouble[LEN];

        /*
        C++ не проверяет выход за границы массива:
        */
        int x[100];
        //x[200]= 5;   // НА БУМАГЕ ошибки НЕ будет, но данные будут повреждены. НА ДЕЛЕ ошибка будет

        /*
        обращение происходит по индексу
        */
        //работа со случайными числами
        srand(time(NULL)); //Без srand(time(NULL)) программа всегда генерирует одно и то же.
        cout << "обращение в массивах происходит по индексу\n";
        for (int i = 0; i < LEN; i++) {
            masDouble[i] = rand();
            /*
            * rand() не даёт случайных чисел - это детерминированная последовательность
            * стандарт от 0 до 32767
            * остатком от деления на число задаётся диапазон (% 10 = от 0 до 9)
            * a + смещение диапозона (1 + rand() % 6 = от 1 до )
            * стандартная формула: a + rand() % (b - a + 1) = от a до b
            */
            cout << masDouble[i] << "\n";
        }
        cout << "\n";

        //Указатели и динамические массивы
        cout << "Указатели и динамические массивы\n\n";
        /*
        Указатель — это переменная, которая хранит адрес памяти, а не значение.
        Пример:
        */

        cout << "задание переменной и его указателя:\nint variable = 10;\nint* pointerVariable = &variable;\n\n";
        int variable = 10;
        int* pointerVariable = &variable; //Всегда присваивай указателям значение при создании

        /*
        Особенности указателей
        Указатель всегда связан с типом, на который он указывает (int*, float*, char*).
        Тип определяет, как интерпретировать память по адресу.

        Указатель на void может указывать на что угодно, но разыменовать его нельзя → нужно приведение.
        
        Операции с указателями:
        */
        cout << "операции с указателями:\n";

        cout << &variable << " вывод адреса переменной variable (&variable)\n\n";
        //Можно брать адрес у любой переменной, кроме временных значений:
        /*
        * int* x = &(5); ошибка — у литерала нет адреса
        * int* y = &(a + 7); нельзя брать адрес у результата выражения
        */

        cout << "Разыменование (int* pointerVariable = &variable) означает «получить значение по адресу, хранящемуся в указателе»:\n";
        cout << *pointerVariable << endl; //cout << pointerVariable выведет адрес
        cout << "Изменение значения переменной через указатель(*pointerVariable = 15), вывод (variable):\n";
        *pointerVariable = 15;
        cout << variable << "\n\n";
        // разыменовывать NULL - опасно
        // явное указание адреса char* cp = (char*)0xB8000000 - редко

        cout << "Указатели можно копировать, и они будут указывать на один и тот же объект (int* pointVariableDuble = pointerVariable):\n";
        int* pointVariableDuble = pointerVariable;
        cout << *pointVariableDuble;
        /*
        Две переменные → один объект в памяти
        Все изменения через любой указатель отражаются на оригинальной переменной.
        */

        cout << "Арифметика указателей\np + 1 → переход на 4 байта вперёд\np - 1 → на 4 байта назад\n";
        cout << "Выводы массива (см. код):\n";
        int arr[5] = {10,20,30,40,50};
        int* pArr = arr; //Имя массива - константный указатель на первый элемент
        cout << *pArr << endl;
        cout << *(pArr + 2) << endl;
        cout << *(pArr + 1) << endl;
        cout << *(pArr - 1) << endl << endl; //вышли за пределы массива

        /*
        работают инкременты (p++) и декременты(p--) для массива
        */

        cout << "Разность указателей имеет смысл только для элементов одного массива(см.код):\n";
        int* pArrIndex1 = &arr[0];
        int* pArrIndex2 = &arr[3];
        cout << pArrIndex2 - pArrIndex1; //Разность указывает количество элементов, а не байт

        cout << "\nСравнение указателей по адресу (см. код):\n";
        cout << pArrIndex1 << " | " << pArrIndex2 << endl;
        (pArrIndex1 < pArrIndex2) ? cout << "true\n" : cout << "false\n";
        (pArrIndex1 = pArrIndex2) ? cout << "true\n" : cout << "false\n";
        (pArrIndex1 > pArrIndex2) ? cout << "true\n\n" : cout << "false\n\n";
        //Работает корректно, если указатели относятся к одному массиву

        //Приведение типов
        /*
        void* vp;
        int a = 10;

        vp = &a;
        int* p = (int*)vp;  - приведение обратно
        */

        //Важное тождество a == *(&a)
        /*
        Области памяти
        1. Глобальная область — статические данные

        2. Стек — локальные переменные, автоматическое выделение

        3. Куча (heap) — динамическая память (new, delete)
        */

        //Нулевые указатели
        int* pNULL = NULL;
        int* pZERO = 0;
        /*
        Нулевой указатель — это указатель, который никуда не указывает.
        Нужны:
        1. Чтобы показывать, что указатель не инициализирован (без = NULL он содержит мусор)
        2. Чтобы избежать ошибок работы с освобождённой памятью
        */

        //константный указатель
        const char* pC1; // одно
        char const* pC2; // и то же данные в указатели неизменны, адрес менть можно

        char* const pC3; // адрес неизменин, данные менять можно

        //Динамическое выделение памяти
        int* pDinamic = new int;
        /*
        Динамический указатель — это указатель, который указывает на память,
        выделенную во время выполнения программы (runtime), а не заранее (compile-time).

        Нужны:
        1. Чтобы создавать объекты, размер которых заранее неизвестен
        Размер массива, структуры или объекта может быть известен только от пользователя или из файла:
        
        int N;
        cin >> N;
        int* arr = new int[N];
        
        2. Чтобы работать с очень большими структурами данных
        int big[10000000]; - Stack overflow
        int* big = new int[10000000]; - Ok

        3. Чтобы создавать и разрушать объекты вручную
        Можно полностью контролировать жизненный цикл объекта
        Это важно, когда:
        - объект нужен только при определённых условиях
        - нужно оптимизировать производительность
        - память дорогая (встроенные устройства, игры, графика)

        4. Чтобы создавать сложные структуры данных
        5. Чтобы выполнять "полиморфное" создание объектов (ООП)
        */

        //Динамический одномерный массив
        /*
        Динамический массив — это массив, размер которого задаётся во время выполнения программы, а не во время компиляции.
        */
        cout << "Динамический массив:\n";
        int LenDMas;
        cin >> LenDMas;
        int* dinamicArr = new int[LenDMas];
        for (int i = 0; i < LenDMas; i++) {
            cout << dinamicArr[i] << endl;
        }

        /*
        Память выделяется под LenDMas объектов типа int, а указатель arr хранит адрес первого элемента.
        Тип массива только один — указатель на базовый тип.

        Каждый элемент в таком случае содержит мусор, а не 0
        int* arr = new int[LenDMas](); - все элементы 0
        */

        /*
        Динамический массив всегда создаётся в куче (heap) — области памяти, которой программа управляет вручную.
        Стек — маленький, автоматический.
        Куча — большая, выделение вручную через new, освобождение через delete.

        Важность динамического массива в том, что он позволяет:
        - создавать структур данных произвольного размера (графы, списки, таблицы, буферы, большие структуры)
        - не знать размер заранее (на вход приходит файл, пользователь вводит значения, данные растут)
        - хранить большие объекты (Стек ограничен (обычно до 1–8 МБ), куча — нет)
        */

        //Правила очистки динамического массива

        /*
        Главное правило:
        ❗️new[] → delete[]
        ❗️new → delete
        */

        delete[] dinamicArr; // После удаления память возвращается в кучу, но указатель остается “висячим”
        dinamicArr = nullptr; // Обнуляем указатель. nullptr - фишка C++, обычно используют NULL
    }

    //Многомерные массивы
    bool lessen4_5 = true;
    string strLessen4_5 = (lessen4_5) ? "Лекция 4-5:\n \n" : "Лекция 4-5 скрыта\n";
    cout << strLessen4_5;
    if (lessen4_5) {
        /*
        Многомерный массив — это структура данных, элементы которой идентифицируются несколькими индексами.
        Каждый индекс относится к своей размерности.

        Примеры:
        - одномерный массив — 1 индекс (1D → вектор)
        - двумерный массив (матрица) — 2 индекса (2D → таблица)
        - трёхмерный массив — 3 индекса (3D → куб)

        Количество измерений не ограничено, но обычно используют до 3.
        Визуальное представление
        
        */

        //объявление двумерного массива
        const int ROWS = 3,COLS = 3; //строки, столбцы
        float mas2D[ROWS][COLS];

        /*
        C++ использует строчное хранение (row-major order):
        быстрее всего изменяется последний индекс, то есть столбец.

        Пример:
        float A[3][10];
        Элементы лежат в памяти в таком порядке:
        A[0][0], A[0][1], ... A[0][9],
        A[1][0], ... A[1][9],
        A[2][0], ... A[2][9]
        */

        //Инициализация
        float mas2D1[ROWS][COLS] = {1,2,3,4,5,6,7,8,9};
        float mas2D2[ROWS][COLS] = {
            {1,2,3},
            {4,5,6},
            {7,8,9}
        };

        //Обращение к элементам
        cout << "Обращение к элементам:\n";
        for (int i = 0; i < ROWS; i++) {
            for (int j = 0; j < COLS; j++) {
                cout << i << " | " << j << " mas2D1: " << mas2D1[i][j] << endl;
                
            } // использование j, i прохода хамедляет исполняемость кода
        }

        //двумерные динамические массивы
        //одномерное предствление
        /*
        Один из способов — хранить 2D массив как 1D.
        Преимущества:
        - вся память одним блоком → быстрее
        - не возникает фрагментации
        */

        cout << "\nСоздание одномерного предствления, обращение к элементам 1D:\n";
        int* mas1D1 = new int[ROWS * COLS];
        for (int i = 0; i < ROWS; i++) {
            for (int j = 0; j < COLS; j++) {
                mas1D1[COLS * i + j] = i * 10 + j;
                cout << i << " | " << j << " mas1D1: " << mas1D1[COLS * i + j] << endl;
            } 
        }

        //Указатели и двумерный массив
        /*
        Двумерный массив — это массив массивов.
        1. объект arr — указатель на массив из 
        2. 4 указателя на массивы из 3 
        3. 4 массива по 3 int
        */
        int arr[4][3];
        /*
        Адрес(arr[i][j]) = Адрес(arr[0][0]) + (COLS * i + j) * k
        где k — число байт типа (например, sizeof(int)).
        */

        // Двумерные динамические массивы через двойной указатель

        int rows = 3; //строки
        int cols = 3; //столбцы

        int** arrDoubleDinamic;
        arrDoubleDinamic = new int* [rows]; //Выделить память под массив указателей

        for (int i = 0; i < rows; i++) { //Для каждой строки выделить память под данные
            arrDoubleDinamic[i] = new int[cols];
        }
        /*
        каждая строка — отдельный блок памяти → возможная фрагментация.
        */

        //очистка памяти
        for (int i = 0; i < rows; i++) {
            delete[] arrDoubleDinamic[i];
            arrDoubleDinamic[i] = nullptr;
        }
        delete[] arrDoubleDinamic;
        arrDoubleDinamic = nullptr;
    }

    //Функции
    bool lessen6 = false;
    string strLessen6 = (lessen6) ? "Лекция 6:\n \n" : "Лекция 6 скрыта\n";
    cout << strLessen6;
    if (lessen6) {
        //Функция - подпраграмма с аргументами
        /*
        Функция — это именованный фрагмент программы, выполняющий строго определённую задачу.
        Программа на C++ состоит из набора функций, среди которых обязательно присутствует главная функция main().
        Именно с неё начинается выполнение программы.

        Каждая функция может:
        - принимать параметры (аргументы);
        - возвращать значение (или не возвращать — при типе void);
        - быть вызвана из любой другой функции, включая саму себя (рекурсия).

        тип имя_функции(список_переменных) {
            тело_функции
        }
        */

        //объявление см закладку "функции"
        cout << "Вызов функций\n\n";
        printer(); //вызов функции без return

        //типы переменных см закладку "типы переменных"

        //Механизм передачи параметров см. "func"

        int alfa = 10;
        int* alfaPointer = &alfa;

        cout << "Функции не использующие ссылки и указатели меняют переменную КОПИЮ переменной\n";
        functionWithParameters(alfa); //фактический параметр
        cout << alfa;

        cout << "\nФункции использующие ссылки и указатели меняют переменную САМУ переменную\n";
        functionWithParameters(alfa, true);
        cout << alfa;

        cout << "\nФункции использующие указатель и указатели меняют переменную САМУ переменную\n";
        functionWithParameters(alfaPointer);
        cout << alfa;
    }

    //строки и символы
    bool lessen7 = true;
    string strLessen7 = (lessen7) ? "Лекция 7:\n \n" : "Лекция 7 скрыта\n";
    cout << strLessen7;
    if (lessen7) {
        /*
        Кодировки, ASCII и кириллица

        ASCII
        Международный стандарт, представляет первые 128 символов (0–127).
        Содержит латиницу, цифры, знаки пунктуации, управляющие символы.
        Каждый символ представлен числом (кодом) → 1 байт.

        Расширенная ASCII (128–255)
        Не стандартизирована международно.
        Используется разными системами по-разному → проблемы с кириллицей.

        Кириллические кодировки
        CP866 — DOS.
        CP1251 — Windows.
        KOI8-R — Unix.

        UTF-8 (2 байта) — современный универсальный стандарт. Переменное кол-во символов. UTF-16,32
        C++ по умолчанию работает с байтовыми строками char*, 
        НЕ поддерживающими Unicode. Для Unicode используется wchar_t, char16_t, char32_t или std::wstring.
        */

        /*
        Тип char — символьные данные

        Число, интерпретируемое как символ ASCII. Поэтому char — это маленький целочисленный тип (1 байт).
        обязательно одинарные кавычки
        */

        char cL7 = 'c' + 1;
        const char CL7 = '9';

        cout << "К символьным переменным можно прибавлять цифры при инициализации\n" << cL7 << "\n" << endl;

        /*
        Тип строки
        Массив символов, который обязательно заканчивается нулевым символом: '\0' - стопкран для функций
        Можно указателем
        */

        char strChars[11]; //Длина строки 10
        /*
        'A' - char 1 байт
        "A" - char 2 байта (символ + "\0")
        */

        //Инициализация строки
        char strCharsL[] = "ASD"; // {'A','S','D'};
        cout << "Вывод строки: " << strCharsL << "\n\n";

        cout << "Ввод строки (Считывает до пробела): ";
        cin >> strChars;
        cout << "Вывод строки: " << strChars << "\n\n";

        cout << "Ввод строки до разделителя: ";
        char strGeline[256];
        cin.getline(strGeline, 256, ';'); //по умолчанию '\n'; разделитель не войдет в строку
        cin.ignore(); //очищаем буфер
        cout << "Вывод строки: " << strGeline << "\n\n";

        //string std
        /*
        динамический массив реализованный указателями, можно добавлять и убирать элементы строки
        безалокация - принцип при котором короткие строки не идту в кучу
        */
        string strStd = "asd";
    }
}

//функции

//void - не возвращает значения, тип данных - возвращает

//программа не скомпилируется если вызывать функцию после main
void printer() {
    cout << "вызов функции printer и inter(int a) " << inter(1) << endl << endl;
    //вызов функции с return
    funcH();
}

int inter(int a) { //переменная а - локальна
    return a + 1;
    /*
    Оператор return выполняет две функции:
    1. Завершает работу текущей функции.
    2. Возвращает управление вызывающей функции.

    Если тип возврата не void, возвращает значение.

    Все операторы после return недостижимы и игнорируются.
    */
}
